;@TODO
;Sanitize input - Number between 01-50, keep running
;               - Single digit number, keep running
;               - 51, HALT
;               - Other input - Bad input message, run again

0011 0000 0000 0000   ;Start at x3000

0101 000 000 1 00000  ;Clear all 8 registers so that repeated prompts don't carry over errors.
0101 001 001 1 00000
0101 010 010 1 00000
0101 011 011 1 00000
0101 100 100 1 00000
0101 101 101 1 00000
0101 110 110 1 00000
0101 111 111 1 00000

                      ;Prints text "2 ^ "
0001 010 010 1 00011  ;R2 = 3
1110 001 00000 0110   ;LEA R1 3 below this line
0110 000 001 000000   ;R0 = Character stored in R1
1111 0000 0010 0001   ;TRAP x21 OUT write character in R0[7:0] to console display
0001 001 001 1 00001  ;R1 + 1
0001 010 010 1 11111  ;R2 - 1
0000 011 1111 11011   ;Branch to next character in text until exhausted
0000 100 00000 0100   ;After printing this text, branch forward 4 lines
0000 0000 0011 0010   ;2
0000 0000 0010 0000   ;<space>
0000 0000 0101 1110   ;^
0000 0000 0010 0000   ;<space>

                      ;Take input n, and store in R0
1111 0000 0010 0000   ;TRAP x20 GETC takes one character from the keyboard
1111 0000 0010 0001   ;TRAP x21 OUT write character in R0[7:0] to console display
0001 000 000 1 10000  ;R0 = R0 - 16
0001 000 000 1 10000  ;R0 = R0 - 16
0001 000 000 1 10000  ;R0 = R0 - 16
0101 001 001 1 00000  ;R1 = 0
0001 001 001 000 000  ;R1 = R1 + R0
0001 001 001 000 001  ;2 * R1
0001 001 001 000 001  ;2 * R1
0001 001 001 000 000  ;R1 = R1 + R0
0001 001 001 000 001  ;2 * R1
1111 0000 0010 0000   ;TRAP x20 GETC takes one character from the keyboard
1111 0000 0010 0001   ;TRAP x21 OUT write character in R0[7:0] to console display
0001 000 000 1 10000  ;R0 = R0 - 16
0001 000 000 1 10000  ;R0 = R0 - 16
0001 000 000 1 10000  ;R0 = R0 - 16
0001 000 001 000 000  ;R0 = R1 + R0
0101 001 001 1 00000  ;R1 = 0

                      ;Calculate 2^n
0001 000 000 1 11111  ;R0 = R0 - 1
0000 100 0001 00010   ;Branch ahead of Stack if R0 < 0 (Counter is exhausted)
0001 100 100 1 10000  ;R4 = -16
1110 001 0000 10000   ;R1 = Bottom of Stack pointer
0110 010 001 000000   ;R2 = Number stored in Stack pointer
0001 010 010 000 010  ;2 * R2
0001 010 010 000 011  ;R2 = R2 + R3
0001 011 010 1 00000  ;R3 = R2
0001 011 011 1 10110  ;R3 - 10
0000 100 0000 00011   ;Branch ahead 3 lines if R3 < 0
0001 010 010 1 10110  ;R2 - 10
0101 011 011 1 00000  ;R3 = 0
0001 011 011 1 00001  ;R3 = 1
0000 011 0000 00001   ;Branch ahead 1 lines if R3 >= 0
0101 011 011 1 00000  ;R3 = 0
0111 010 001 000000   ;Store R2 in R1 Address
0001 001 001 1 00001  ;R1 = R1 + 1
0001 100 100 1 00001  ;R4 += 1
0000 100 1111 10001   ;Branch N (if the R4 counter is still negative, jump up 14 lines)
0000 011 1111 01100   ;Branch ZP (if the whole stack has been doubled, jump up 18 lines)

0000000000000001      ;This is the stack for counting numbers
0000000000000000      ;Starts at 1 because (2^n, n=0) = 1
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000
0000000000000000

                      ;Prints text " = "
0101 010 010 1 00000  ;R2 = 0
0001 010 010 1 00010  ;R2 = 2
1110 001 00000 0110   ;LEA R1 3 below this line
0110 000 001 000000   ;R0 = Character stored in R1
1111 0000 0010 0001   ;TRAP x21 OUT write character in R0[7:0] to console display
0001 001 001 1 00001  ;R1 + 1
0001 010 010 1 11111  ;R2 - 1
0000 011 1111 11011   ;Branch to next character in text until exhausted
0000 100 00000 0011   ;After printing this text, branch forward 3 lines
0000 0000 0010 0000   ;<space>
0000 0000 0011 1101   ;=
0000 0000 0010 0000   ;<space>

                      ;Prints out the result & resets stack
1110 011 1111 10011   ;R3 = The line below the stack
0101 100 100 1 00000  ;R4 = 0
0001 100 100 1 01111  ;R4 = R4 + 15
0001 100 100 1 00001  ;R4 = R4 + 1
0001 011 011 1 11111  ;R3 - 1
0001 100 100 1 11111  ;R4 - 1
0110 010 011 000000   ;R2 = Number stored in R3 (Top of Stack)
0000 010 1111 11100   ;Branch back 3 if R2 == 0
0000 101 0000 00010   ;Branch ahead 2 if R2 != 0
0001 011 011 1 11111  ;R3 - 1
0110 010 011 000000   ;R2 = Number stored in R3 (Top of Stack)
0101 000 000 1 00000  ;R0 = 0
0111 000 011 000000   ;Store R0 in R3 Address
0001 000 010 1 00000  ;R0 = R2
0001 000 000 1 01111  ;R0 = R0 + 15
0001 000 000 1 01111  ;R0 = R0 + 15
0001 000 000 1 01111  ;R0 = R0 + 15
0001 000 000 1 00011  ;R0 = R0 + 3
1111 0000 0010 0001   ;TRAP x21 OUT write character in R0[7:0] to console display
0001 100 100 1 11111  ;R4 - 1
0000 011 1111 10100   ;Branch to next number in stack until the stack is exhausted
1110 000 1110 01110   ;Load top of stack into R0
0101 001 001 1 00000  ;R1 = 0
0001 001 001 1 00001  ;R1 = R1 + 1
0111 001 000 000000   ;Store R0 in R1 Address

                      ;Prints newline
1110 001 00000 0011   ;LEA R1 3 below this line
0110 000 001 000000   ;R0 = Character stored in R1
1111 0000 0010 0001   ;TRAP x21 OUT write character in R0[7:0] to console display
0000 111 00000 0001   ;After printing this text, branch forward 1 lines
0000 0000 0000 1010   ;<newline>

                      ;Jump back to the start.
1110 000 1100 01011   ;Load x3000 into R0
1100 000 000 000000   ;JMP to R0[address]