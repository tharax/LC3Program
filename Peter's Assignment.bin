;PETER ROSSER
;ID 3740602
;UPI pros028
;A simple program that calculates 2^N where N is between 1-50


0011 0000 0000 0000	;start at x3000

0101 000 000 1 00000	;Clear all 8 registers so that repeated prompts don't carry over errors.
0101 001 001 1 00000
0101 010 010 1 00000
0101 011 011 1 00000
0101 100 100 1 00000
0101 101 101 1 00000
0101 110 110 1 00000
0101 111 111 1 00000

0000 111 00001 0010	;Unconditionally branch 18 lines ahead.

1110 000 00000 0010	;LEA R0 2, to the bad input text block.
1111 0000 0010 0100	;TRAP x24 prints out the bad input text block.
0000 111 00001 0100	;Unconditionally branch 20 lines ahead.

					;Bad input, please try again.
0110 0001 0100 0010	;Ba
0010 0000 0110 0100	;d<space>
0110 1110 0110 1001	;in
0111 0101 0111 0000	;pu
0010 1100 0111 0100	;t<,>
0111 0000 0010 0000	;<space>p
0110 0101 0110 1100	;le
0111 0011 0110 0001	;as
0010 0000 0110 0101	;e<space>
0111 0010 0111 0100	;tr
0010 0000 0111 1001	;y<space>
0110 0111 0110 0001	;ag
0110 1001 0110 0001	;ai
0010 1110 0110 1110	;n<.>
0000 0000 0000 1010	;newline
0000 0000 0000 0000

1110 000 00101 1001	;LEA R0 89, to the block about student details.
1111 0000 0010 0100	;TRAP x24 prints out the student details block.

1110 000 00000 0010	;LEA R0 2, to the quit text block.
1111 0000 0010 0100	;TRAP x24 prints out the quit text block.
0000 111 00001 1010	;Unconditionally branch 26 lines ahead.

					;To quit at any time, enter " 51 " at the prompt.
0110 1111 0101 0100	;To
0111 0001 0010 0000	;<space>q
0110 1001 0111 0101	;ui
0010 0000 0111 0100	;t<space>
0111 0100 0110 0001	;at
0110 0001 0010 0000	;<space>a
0111 1001 0110 1110	;ny
0111 0100 0010 0000	;<space>t
0110 1101 0110 1001	;im
0010 1100 0110 0101	;e,
0110 0101 0010 0000	;<space>e
0111 0100 0110 1110	;nt
0111 0010 0110 0101	;er
0010 0010 0010 0000	;<space>"
0011 0101 0010 0000	;<space>5
0010 0000 0011 0001	;1<space>
0010 0000 0010 0010	;"<space>
0111 0100 0110 0001	;at
0111 0100 0010 0000	;<space>t
0110 0101 0110 1000	;he
0111 0000 0010 0000	;<space>p
0110 1111 0111 0010	;ro
0111 0000 0110 1101	;mp
0010 1110 0111 0100	;t.
0000 0000 0000 1101	;<newline>
0000 0000 0000 0000

					;----------------------------------------PROMPT
1110 000 00110 1000	;LEA R0 104, x48 down from this line
1111 0000 0010 0100	;TRAP x24 (PUTSP) - prints the prompt for "n"
1110 000 01111 1111	;LEA R0, to x3100
0001 000 000 1 00010	;add 1 to r0

1110 110 1100 00100	;Load into r6 an address 128 above this line, for storing the input details
0001 001 001 1 00010	;add 2 to counter in r1
1111 0000 0010 0000	;TRAP x20 GETC - takes one character from the keyboard
1111 0000 0010 0001	;TRAP x21 OUT - write character in R0[7:0] to console display

0111 000 110 000000		;store the character at r0 into r6[address]
0001 000 000 1 10111	;subtract 9 from r0 (check if it is a whitespace - tab)
0000 010 0000 00001		;branch to end (its a tab)
0001 000 000 1 11111	;subtract 10 from r0 (check if it is a whitespace - line feed)
0000 010 0000 00010		;branch to end (its a linefeed)
0001 000 000 1 10110	;subtract 10 from r0
0001 000 000 1 10100	;subtract 12 from r0 (check if it is a whitespace - space)
0000 010 0000 00011		;branch to end (its a space)
0001 010 010 1 00001	;add 1 to counter in r2 (input length counter)
0001 110 110 1 00001	;add 1 to r6[address] counter
0000 111 1111 10011		;branch NZP back up to line 13 above this
;1111 0000 0010 0101	;halt <-------------- SHOULD BE BRANCH TO "BAD INPUT"---------CHANGE ME

						;check to see if the input is too long or no input.
0101 011 011 1 00000	;wipe register 3
0001 010 010 1 11110	;subtract 2 from r2 (input length counter)
0000 001 1101 11000		;branch back 47 to BAD INPUT				;x304F
0001 010 010 1 00010	;add 2 back to the r2 counter.
0000 010 1111 11101		;branch back 2 and hitch a ride to BAD INPUT
0001 010 010 1 11111	;check to see if the input is 1 (by subtracting one and
						; branching if it is zero)
0000 010 0000 00001		;branch to loading r3 with x30
0000 001 0000 00100		;if the answer is still positive, branch down two
0001 011 011 1 01111	; 
0001 011 011 1 01111	;
0001 011 011 1 01111	;
0001 011 011 1 00011	;add x30 to r3
0001 010 010 1 00001	;add 1 back to the r2 counter

0101 100 100 1 00000	;wipe register 4

1110 110 1011 00110		;Load into r6 the start of the stack address
0001 110 110 1 00001	;add 1 to r6
0110 000 110 000000		;load r6[contents] into r0
0101 111 111 1 00000	;wipe r7
0111 111 110 000000		;store r7 in r6 address (to wipe the stack for repeat uses)

0001 010 010 1 11111	;decrease counter in r2 by 1
0000 100 0000 00001		;branch Nzp <-this line should never be run
0000 010 0000 00001		;branch nZp forward 2 if it's zero
0001 011 000 1 00000	;add to r3 the number in r0
0001 100 000 1 00000	;add to r4 the number in r0
0001 001 001 1 11111	;decrease counter in r1 by 1
0000 001 11111 0101		;branch nzP back 2 if the result is still positive
0001 101 100 1 00000	;add to r5 what is in r4
0001 101 101 1 10000	;subtract 16 from r5
0001 101 101 1 10000	;subtract 16 from r5
0001 101 101 1 10000	;subtract 16 from r5
0001 101 101 1 11111	;subtract 1 from r5
0000 101 0000 00111		;if result is negative or positive, branch past this "51" check
0001 101 011 1 00000	;add to r5 what is in r3
0001 101 101 1 10000	;subtract 16 from r5
0001 101 101 1 10000	;subtract 16 from r5
0001 101 101 1 10000	;subtract 16 from r5
0001 101 101 1 11011	;subtract 5 from r5
0000 101 0000 00001		;if result is negative or positive, branch past this "51" check
1111 0000 0010 0101		;halt

0000 111 00100 0100	;branch NZP to the end of the two text blocks below.

					;NAME: Peter Rosser
0100 0001 0100 1110	;NA
0100 0101 0100 1101	;ME
0010 0000 0011 1010	;:<space>
0110 0101 0101 00000;Pe
0110 0101 0111 0100	;te
0010 0000 0111 0010	;r<space>
0110 1111 0101 0010	;Ro
0111 0011 0111 0011	;ss
0111 0010 0110 0101	;er

					;UPI :pros028
0101 0101 0000 1101	;<newline>U
0100 1001 0101 0000	;PI
0011 1010 0010 0000	;<space>:
0111 0000 0010 0000	;<space>p
0110 1111 0111 0010	;ro
0011 0000 0111 0011	;s0
0011 1000 0011 0010	;28

					;AUID: 3740602
0100 0001 0000 1101	;<newline>A
0100 1001 0101 0101	;UI
0011 1010 0100 0100	;D:
0010 0000 0000 0000	;<space><null>
0011 0111 0011 0011	;37
0011 0000 0011 0100	;40
0011 0000 0011 0110	;60
0000 1101 0011 0010	;2<newline>

					;Compsci 210 2010 Semester 1
0110 1111 0100 0011	;Co
0111 0000 0110 1101	;mp
0110 0011 0111 0011	;sc
0010 0000 0110 1001	;i<space>
0011 0001 0011 0010	;21
0010 0000 0011 0000	;0<space>
0011 0000 0011 0010	;20
0011 0000 0011 0001	;10
0101 0011 0010 0000	;<space>S
0110 1101 0110 0101	;em
0111 0011 0110 0101	;es
0110 0101 0111 0100	;te
0010 0000 0111 0010	;r<space>
0000 1101 0011 0001	;1<newline>

					;Assignment 2
0111 0011 0100 0001	;As
0110 1001 0111 0011	;si
0110 1110 0110 0111	;gn
0110 0101 0110 1101	;me
0111 0100 0110 1110	;nt
0011 0010 0010 0000	;<space>2
0000 0000 0000 1010	;<newline><null>
0000 0000 0000 0000	;

					;Please enter an integer between 1 and 50: 
0110 1100 0101 0000	;Pl
0110 0001 0110 0101	;ea
0110 0101 0111 0011	;se
0110 0101 0010 0000	;<space>e
0111 0100 0110 1110	;nt
0111 0010 0110 0101	;er
0110 0001 0010 0000	;<space>a
0010 0000 0110 1110	;n<space>
0110 1110 0110 1001	;in
0110 0101 0111 0100	;te
0110 0101 0110 0111	;ge
0010 0000 0111 0010	;r<space>
0110 0101 0110 0010	;be
0111 0111 0111 0100	;tw
0110 0101 0110 0101	;ee
0010 0000 0110 1110	;n<space>
0010 0000 0011 0001	;1<space>
0110 1110 0110 0001	;an
0010 0000 0110 0100	;d<space>
0011 0000 0011 0101	;50
0010 0000 0011 1010	;:<space>
0000 0000 0000 0000	;

1110 000 00000 0010	;LEA 2 down from this line
1111 0000 0010 0100	;TRAP x24 (PUTSP) - prints out the Result part a text block
0000 111 00000 0110	;after trap, branch forward 6 lines

					;Power (2,
0110 1111 0101 0000	;Po<-------------Start of "Result(a)"
0110 0101 0111 0111	;we
0010 0000 0111 0010	;r<space>
0011 0010 0010 1000	;(2
0000 0000 0010 1100	;,<null>
0000 0000 0000 0000	;<---------------end of "Result(a)"

0101 000 000 1 00000	;clear R0 (R0 AND 0)
0001 000 011 1 00000 	;copy number from R3 to R0
1111 0000 0010 0001	;trap x21 (print character in r0)

0101 000 000 1 00000	;clear R0 (R0 AND 0)
0001 000 100 1 00000 	;copy number from R4 to R0
1111 0000 0010 0001	;trap x21 (print character in r0)

1110 000 00000 0010	;LEA 2 down from this line
1111 0000 0010 0100	;TRAP x24 (PUTSP) - prints out the Result part b text block
0000 111 00000 0011	;after trap, branch forward 3 lines

0010 0000 0010 1001 	;)<space><-------Start of "Result(b)"
0010 0000 0011 1101	;=<space><-------end of "Result(b)"
0000 0000 0000 0000	;<---------------end of "Result(b)"
		
0101 000 000 1 00000	;clear r0 register

			;test to check that second ASCII character is a number
0001 100 100 1 10000	;subtract xF(16) from number in r4, store in r4
0001 100 100 1 10000	;subtract xF(16) from number in r4, store in r4
0001 100 100 1 10000	;subtract xF(16) from number in r4, store in r4
0001 100 100 1 10000	;subtract xF(16) from number in r4, store in r4
0000 011 0000 00011	;if the result is zero or positive, branch forward 3 lines
0001 100 100 1 01010	;add xA(10) to number in r4, store in r4
0001 100 100 1 00110	;add x6(6) to number in r4, store in r4
0000 100 0000 01010	;if the result is negative, branch forward 1 lines

0000 111 0000 00000 	;the second character is not a number! branch to BAD INPUT
			
			;test to check that first ASCII character is a number
0001 011 011 1 10000	;subtract xF(16) from number in r3, store in r3
0001 011 011 1 10000	;subtract xF(16) from number in r3, store in r3
0001 011 011 1 10000	;subtract xF(16) from number in r3, store in r3
0001 011 011 1 10000	;subtract xF(16) from number in r3, store in r3
0000 011 0000 00100	;if the result is zero or positive, branch forward 4 lines
0001 011 011 1 01010	;add xA(10) to number in r3, store in r3
0001 011 011 1 00110	;add x6(6) to number in r3, store in r3
0000 100 0000 00001	;if the result is negative, branch forward 1 lines
0000 111 0000 00010	;if the result is anything, branch forward 1 lines
1110 000 1001 01011	;should load back 210 places, to BAD INPUT
1100 000 000 000000	;jump to r0[address], BAD INPUT

			;this block takes the first integer and multiplies it by ten, then stores it.
0101 001 001 1 00000	;clear register r1
0101 101 101 1 00000	;clear register r5
0001 001 001 1 01010	;put "10" in register r1 (counter)
0001 101 101 000 011	;add register r3 and r5, put in register r5
0001 001 001 1 11111	; subtract one from register r1 (decrease counter)
0000 001 1111 11101	;while counter is positive, branch back 2 
0011 101 0110 11111	;store value in r5 at 111 numbers from here.

0101 011 011 1 00000	;clear register r3
0001 011 100 000 101	;add r4 and r5, store in r3 <-- this is the counter for duplicating the numbers

0101 100 100 1 00000	;clear register r4
0001 100 100 1 00001	;add 1 to r4, store in r4
0011 100 0110 00111	;store this value in r4 memory in location of stack --------THIS LINE IS ON x30EF

			;calculator - 	pop a single integer from stack, double it, add overflow to next calculation
			;	      	then return single int to stack, move pointer, repeat process until the 
			;	      	entire loop is done.

0101 001 001 1 00000	;clear register 1 (used for current number)
0101 010 010 1 00000	;clear register 2 (used for overflow)
			;      register 3 has the (n) counter for 2^(n)
0101 100 100 1 00000	;clear register 4 (used for counting how far through stack we are)
0101 101 101 1 00000	;clear register 5 (used for stack pointer)

0001 011 011 1 11111	;reduce r3 by 1
0000 100 0000 10001	;if r3 is negative or zero, branch ahead to end of this calculator
1110 101 0110 00000	;LEA load address at start of stack from here into r5
0001 100 100 1 10000	;set counter in r4 at -16
0110 001 101 0000 00	;load values from r5[address] into r1
0001 001 001 000 001	;double the value in r1, put in r1
0001 001 001 000 010	;add the value in r2(overflow, if it exists), to r1
0101 010 010 1 00000	;clear r2
0001 001 001 1 10110	;subtract ten from r1(for overflow test), put result in r1
0000 011 0000 00001	;if its Z or P, branch 1 ahead
0000 100 0000 00010	;if its N, branch 2 ahead
0001 010 010 1 00001	;the result is over ten, add 1 to r2
0000 111 0000 00001	;BR NZP 1 ahead
0001 001 001 1 01010	;add ten back to r1, put result in r1
0111 001 101 000000	;store the (single)value that is in r1 in the address
0001 101 101 1 11111	;subtract 1 from counter in r5
0001 100 100 1 00001	;add 1 to counter in r4 
0000 100 1111 10010	;br N (if the r4 counter is still negative, jump up 13 lines)
0000 011 1111 01100	;br ZP (if the code to repeat 16 times is done, jump up 17 lines)

			;final adjustment : turns ints into ascii characters of the same number.
1110 101 0101 01111	;LEA load address at end of stack (x3148) from here into r5
0101 100 100 1 00000	;clear register 4 (used for counting how far through stack we are)
0001 100 100 1 10000	;set counter in r4 at -16
0110 001 101 0000 00	;load values from r5[address] into r1
0001 001 001 1 01100	;add 12 to value in r1
0001 001 001 1 01100	;add 12 to value in r1  
0001 001 001 1 01100	;add 12 to value in r1
0001 001 001 1 01100	;add 12 to value in r1	<-- added 48 to the number (should add x30 to the value in r1)
0111 001 101 000000	;store the (single)value that is in r1 in the r5[address] (should have converted number to
			;it's ascii value.
0001 101 101 1 00001	;add 1 to counter in r5
0001 100 100 1 00001	;add 1 to counter in r4
0000 100 1111 10111	;br N (if the r4 counter is still negative, jump up 13 lines)

			;print out the result, ignoring leading 0's, and adding commas.
1110 000 0101 00011	;LEA load address at end (high value end) of stack (x3148) from here into r0
0101 100 100 1 00000	;clear register 4 (used for counting how far through stack we are)
0101 110 110 1 00000	;clear register 6 (used for counting when to place commas)
0001 110 110 1 00010	;set register 6 to 2
0001 100 100 1 10000	;set counter in r4 at -16
0001 110 110 1 11111	;reduce register 6 by 1
0000 101 0000 00010	;if register 6 is N or positive, jump down 3
0000 010 0000 00000	;if register 6 is Z, jump down 1
0001 110 110 1 00011	;add 3 to register 6
0110 001 000 0000 00	;load values from r0[address] into r1
0001 100 100 1 00001	;add 1 to counter in r4
0001 000 000 1 00001	;add 1 to counter in r0
0001 001 001 1 10100	;subtract 12 from r1 value
0001 001 001 1 10100	;subtract 12 from r1 value
0001 001 001 1 10100	;subtract 12 from r1 value
0001 001 001 1 10100	;subtract 12 from r1 value (should have subtracted 48 (x30) to check if this is a leading 
			;zero
0000 010 1111 11000	;br Z - jump back up 7 lines
0001 000 000 1 11111	;take 1 back off counter in r0, because now you are at the leading number.


0101 101 101 1 00000	;clear register 5 (we'll use for stack pointer)
0001 101 101 0 00 000	;copy the pointer in r0 to r5
0110 000 101 000 000	;load the information at r5[address] to r0
0101 111 111 1 00000	;wipe r7
1111 0000 0010 0001	;trap x21 - print the single character in r0 to console
0001 110 110 1 11111	;reduce register 6 by 1
0000 101 0000 01000	;if register 6 is N or positive, jump down 8 <--- not comma time yet
0000 010 0000 00000	;if register 6 is Z, jump down 1 <---- comma needs to be added
0101 000 000 1 00000	;clear register 0
0001 000 000 1 01111	;add 15 to register 0
0001 000 000 1 01111	;add 15 to register 0
0001 000 000 1 01110	;add 14 to register 0 
			;by here you should have added 44, or x2C, which is the ascii code for comma
1111 0000 0010 0001	;trap x21 - print the single character (ie. comma) in r0 to console
0001 110 110 1 00011	;add 3 to register 6
0110 000 101 0000 00	;load values from r5[address] into r0
0111 111 101 000000	;store r7(nothing) in the r5 address
0001 101 101 1 00001	;add 1 to counter in r5
0001 100 100 1 00001	;add 1 to counter in r4
0000 100 1111 10010	;br N - jump back up 14 lines
0110 000 101 0000 00	;load values from r5[address] into r0
0001 101 101 1 00001	;store 1 in the r5 address
1111 0000 0010 0001	;trap x21 - print the single character in r0 to console

			;loop to reset all inserted numbers, and re-prompt
			;quick loop to reset every level of the stack to 0
;0101 001 001 1 00000	;clear register r1
;1110 101 0010 10011	;LEA load address at start of stack from here into r5
;0001 100 100 1 10000	;set counter in r4 at -16
;0111 001 101 000000	;store contents of r1 (0) into r5[address]
;0001 101 101 1 11111	;subtract 1 from counter in r5
;0001 100 100 1 00001	;add 1 to counter in r4 
;0000 100 1111 11010	;br N (if the r4 counter is still negative, jump up 13 lines)
;0000 011 0000 00000	;br ZP (if the code to repeat 16 times is done, jump up 17 lines)
0101 000 000 1 00000	;clear register r0
0101 001 001 1 00000	;clear register r1
0101 010 010 1 00000	;clear register r2
0101 011 011 1 00000	;clear register r3
0101 100 100 1 00000	;clear register r4
0101 101 101 1 00000	;clear register r5
0101 110 110 1 00000	;clear register r6
0101 111 111 1 00000	;clear register r7
1110 000 1 0000 0100	;LEA into r0 x3027, where the prompt code starts.

1100 000 000 000000	;JMP to r0[address]


;TO CODE LIST			
			;so that prompt repeats after giving an answer

			;error if input is bad

			;allow for single digit inputs





			;answer part b of assignment


1111 0000 0010 0101	;TRAP x25 (HALT) - halt the program


